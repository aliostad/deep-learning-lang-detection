namespace Informedica.GenOrder.Lib

/// Types and functions that presents a `Prescription`, i.e. either a 
/// process, or a continuous prescription or a discontinuous prescription
/// with or without a time
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module Prescription =
    
    module FR = VariableUnit.Frequency
    module TM = VariableUnit.Time

    /// Type that represents a prescription
    type Prescription = 
        /// A process
        | Process
        /// A continuous infusion
        | Continuous
        /// A discontinuous presciption with a frequency
        | Discontinuous of FR.Frequency
        /// A discontinuous prescription with both frequency and time
        | Timed of FR.Frequency * TM.Time

    /// A `Process`
    let ``process`` = Process

    /// Create `Frequency` and `Time` with name generated by string list **n**
    let freqTime n =  (n |> FR.frequency, n |> TM.time)

    /// Create a continuous `Prescription` with name generated by string list **n**
    let continuous n =  let _, _ = n |> freqTime in Continuous

    /// Create a discontinuous `Prescription` with name generated by string list **n**
    let discontinuous n =  let frq, _ = n |> freqTime in frq |> Discontinuous
    
    /// Create a timed `Prescription` with name generated by string list **n**
    let timed n = let frq, tme = n |> freqTime in (frq, tme) |> Timed
    
    /// Check whether a `Presciption` is continuous
    let isContinuous = function | Continuous -> true | _ -> false

    /// Check whether a `Presciption` is discontinuous with a time
    let isTimed = function | Timed _ -> true | _ -> false

    /// Turn `Prescription` **prs** into `VariableUnit`s to
    /// be used in equations
    let toEqs prs =
        match prs with
        | Process    -> None, None
        | Continuous -> None, None
        | Discontinuous (frq) -> frq |> FR.toVarUnt |> Some, None
        | Timed(frq, tme)     -> frq |> FR.toVarUnt |> Some, tme |> TM.toVarUnt |> Some

    /// Set a list of `Equation` **eqs** to a `Prescription` **prs** 
    let fromEqs eqs prs =
        match prs with
        | Process    -> Process
        | Continuous -> Continuous
        | Discontinuous (frq) -> (frq |> FR.fromVar eqs) |> Discontinuous
        | Timed(frq, tme)     -> (frq |> FR.fromVar eqs, tme |> TM.fromVar eqs) |> Timed
        
    /// Turn a `Prescription` **prs** into 
    /// a string list 
    let toString (prs: Prescription) =
            match prs with
            | Process    -> ["Process"]
            | Continuous -> ["Continuous"]
            | Discontinuous (frq) -> [frq |> FR.toString]
            | Timed(frq, tme)     -> [frq |> FR.toString; tme |> TM.toString]
        
                
        

