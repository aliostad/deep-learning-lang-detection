<#
 
.SYNOPSIS
Queries Google to identify hostnames within a given domain name.
 
.DESCRIPTION
This tool make use of Google search APIs to extract hostnames that are indexed in the Google searchengine database for a given DNS domain. The module issues the initial query "site:example.com" and then appends any identified names (the left-most part of the FQDN in the search results) as exlusions in each subsequent search query. It does so until no new names are found.

The tool supports the use of two Google APIs: Google Web Search (Native) and Google Custom Search (Custom). 

The Google Web Search API is the "old" search API and can be used without a API key. The query generated by the module forces "large" result collections ("rsz = large"), providing 8 search results per query.

The Google Custom Search is the search API currently supported by Google and requires an API key and a Search engine ID. The module issues a default query, providing a collection of 10 search results per query. The API key for Custom Search must be stored in the file "$NMEVars.HomeDir\config\google_apikey.txt" and the Engine ID in the file "$NMEVars.HomeDir\config\google_engineid.txt".

The tool outputs objects with "Query" (domain name) and "HostName" information.

.PARAMETER Domain
The target domain, specified as a single FQDN. The tool also supports multiple domain names by means of DNSDomain objects coming through the pipeline.

.PARAMETER API
The API(s) used for the query, supporting "Native" and/or "Custom". The default value is "Native".

.PARAMETER FeedDNS
Passes identified names to the Invoke-DNSQuery module, for hostname verification and for saving the results to the corresponding DNSDomain object.

.EXAMPLE
NME-HTTP-GoogleHostnames -Domain example.com

.EXAMPLE
<Objects>| NME-HTTP-GoogleHostnames -API Custom,Native

.NOTES

Module dependencies
-------------------
- Environment: HelperFunctions
- MapEnum: Invoke-DNSQuery

.LINK
 
Google Web Search API
- https://developers.google.com/web-search/docs/

Google Custom Search API
- https://developers.google.com/custom-search/json-api/v1/overview

#>

Function Invoke-GoogleHostnames
{
    Param
    (
        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
        [Alias("DomainName")]
        [string]$Domain,

        [Parameter()]
        [ValidateSet('Native','Custom')]
        [string[]]$API = "Native",

        [Parameter()]
        [switch]$FeedDNS
    )
    
    BEGIN
    {
        #Default functions/variables
        $CmdName = 'Invoke-GoogleHostnames'
        $CmdAlias = 'NME-HTTP-GoogleHostnames'
        $Results = @()

        #Module-specific functions/variables
        Add-Type -Assembly System.Web

        If($API.Contains('Custom'))
        {
            if((Test-Path "$($NMEVars.HomeDir)\config\google_apikey.txt") -and (Test-Path "$($NMEVars.HomeDir)\config\google_engineid.txt"))
            {
                $apikey = Get-Content "$($NMEVars.HomeDir)\config\google_apikey.txt"
                $engid = Get-Content "$($NMEVars.HomeDir)\config\google_engineid.txt"
            }
            else
            {
                $message = 'Custom search API key and/or engine id not found'
                LogEvent -command $CmdName -severity Err -Event $message -ToConsole

                Break
            }
        }
    }

    PROCESS
    {
        $hostnames = @()

        if($Api.Contains('Native'))
        {
            $result = $null

            try
            {
                $message = 'Conducting Google subname search (native api)'
                LogEvent -source $Domain -command $CmdName -severity Info -Event $message -ToFile -ToConsole

                do {
                    if (!$result) #Setting initial search values
                    {
                        $qstr = $Domain
                        $last = $qstr
                    }
                    else #Parsing results
                    {
                        $fqdn = @(foreach ($i in $result.responseData.results){((($i.url) -split "/")[2])}) |Select -Unique #Exctacting subdomains/hostnames from query results
                        $hostnames += @($fqdn)

                        $equal = @(Compare-Object $fqdn $last -SyncWindow 0).Length -eq 0 #Checks if current results collection is identical to last
                                
                        if($equal -eq $true) #Breaks do-while-loop if results collection is identical (assuming that no more search hits are available)
                        {
                            break
                        }

                        $last = $fqdn

                        foreach($i in $fqdn) #Building new search string with search exclusions (e.g "-www") based on leftmost part of identified fqdns
                        {
                            if($i -ne $Domain)
                            {
                                $_i = ($i -split "\.")[0]

                                if ($qstr -notmatch "-$_i\b")
                                {
                                    $qstr += "{0}{1}" -f " -",$_i
                                }
                            }
                        }
                    }

                    #Building query string
                    $query = [web.httputility]::UrlEncode("site:$qstr")
                    $search = "http://ajax.googleapis.com/ajax/services/search/web?v=1.0&rsz=large&q=${query}"

                    Write-Verbose 'Sending search query...'
                    $result = Invoke-RestMethod $search #Querying Google

                    } while ($result.responseData.results)
            }
            catch
            {
                $message = $_.Exception.Message
                LogEvent -source $Domain -command $CmdName -severity Err -Event $message -ToFile -ToConsole
            }
        }

        if($Api.Contains('Custom'))
        {
            $result = $null

            try
            {
                $message = 'Conducting Google subname search (custom api)'
                LogEvent -source $Domain -command $CmdName -severity Info -Event $message -ToFile -ToConsole

                do {
                        if (!$result) #Setting initial search values
                        {
                            $qstr = $Domain
                            $last = $qstr
                        }
                        else #Parsing results
                        {
                            $fqdn = @(foreach ($i in $result.items){((($i.link) -split "/")[2])}) |Select -Unique #Exctacting subdomains/hostnames from query results
                            $hostnames += @($fqdn)

                            $equal = @(Compare-Object $fqdn $last -SyncWindow 0).Length -eq 0 #Checks if current results collection is identical to last

                            if(($equal -eq $true) -or (!$result.items)) #Breaks do-while-loop if results collection is identical (assuming that no more search hits are available)
                            {
                                break
                            }

                            $last = $fqdn

                            foreach($i in $fqdn) #Building new search string with search exclusions (e.g "-www") based on leftmost part of identified fqdns
                            {
                                if($i -ne $Domain)
                                {
                                    $_i = ($i -split "\.")[0]

                                    if ($qstr -notmatch "-$_i\b")
                                    {
                                        $qstr += "{0}{1}" -f " -",$_i
                                    }
                                }
                            }
                        }

                        #Building query string
                        $query = [web.httputility]::UrlEncode("site:$qstr")
                        $search = "https://www.googleapis.com/customsearch/v1?key=$apikey&cx=$engid&q=$query"

                        Write-Verbose 'Sending search query...'
                        $result = Invoke-RestMethod $search #Querying Google

                    } while($result.items)
            }
            catch
            {
                $message = $_.Exception.Message
                LogEvent -source $Domain -command $CmdName -severity Err -Event $message -ToFile -ToConsole
            }
        }

        $hostnames = ($hostnames |?{$_ -ne $Domain})|select -Unique #Compiling list of unique hostnames, exluding the initial query domain

        if($hostnames.Count -gt 0)
        {
            $message = 'Hostnames found'
            LogEvent -source $Domain -command $CmdName -severity Succ -Event $message -ToFile -ToConsole

            foreach($s in $hostnames)
            {
                $nameObj = New-Object psobject -Property @{
                    Query   = $Domain
                    HostName = $s
                } |Select Query,HostName

                $Results += $nameObj
            }

            if($FeedDNS)
            {
                $message = 'Saving results to DNS'
                LogEvent -source $Domain -command $CmdName -severity Info -Event $message -ToFile -ToConsole
                
                [void]($Results |Invoke-DNSQuery -RecordType A) #Assuming that results are A records
            }
        }
        else
        {
            $message = 'No hostnames found'
            LogEvent -source $Domain -command $CmdName -severity Info -Event $message -ToFile -ToConsole
        }
    }

    END
    {
        Write-Output $Results
    }
}