package AXIChisel

import Chisel._
import Literal._
import Node._
import AXILiteDefs._

// a Chisel traslation of the AXI Lite Slave template code generated by Vivado
// with some simplifications (no byte-addressing in writes, no mux on read data output)

class SimpleReg(regCount: Int, addrBits: Int, dataBits: Int) extends Module {
  val io = new AXILiteSlaveIF(addrBits, dataBits)
  
  val regBank = Vec.fill(regCount) {Reg(init=UInt(0, width=dataBits))}
  val wordSelBits = log2Up(dataBits/8)
  
  // rename AXI signals to match Xilinx templates
  io.renameSignals()
  
  // register for write address channel ready signal
  val writeAddrReadyReg = Reg(init=Bool(false))
  val canDoWrite = io.writeAddr.valid && io.writeData.valid && !writeAddrReadyReg
  writeAddrReadyReg := canDoWrite
  io.writeAddr.ready  := writeAddrReadyReg
  
  // register for keeping write address
  val writeAddrReg = Reg(init=UInt(0, addrBits))
  when (canDoWrite) {writeAddrReg := io.writeAddr.bits.addr}
  
  val writeReadyReg = Reg(init=Bool(false), next=canDoWrite)
  io.writeData.ready := writeReadyReg
  
  // register bank write
  val doWrite = writeReadyReg && io.writeData.valid && writeAddrReadyReg && io.writeAddr.valid
  val writeRegSelect = writeAddrReg(addrBits-1, wordSelBits)
  // note that we write the entire word (no byte select using write strobe)
  when (doWrite) { regBank(writeRegSelect) := io.writeData.bits.data }
  
  // write response generation
  io.writeResp.bits   := UInt(0)        // always OK
  val writeRespValidReg = Reg(init=Bool(false))
  writeRespValidReg := doWrite && !writeRespValidReg
  io.writeResp.valid  := writeRespValidReg
  
  // read address ready generation
  val readAddrReadyReg = Reg(init=Bool(false))
  val canDoRead = !readAddrReadyReg && io.readAddr.valid
  readAddrReadyReg := canDoRead
  io.readAddr.ready := readAddrReadyReg
  
  // read address latching
  val readAddrReg = Reg(init=UInt(0, addrBits))
  when (canDoRead) { readAddrReg := io.readAddr.bits.addr }
  
  // read data valid and response generation
  val readValidReg = Reg(init=Bool(false))
  val doRead = readAddrReadyReg && io.readAddr.valid && !readValidReg
  readValidReg := doRead
  
  io.readData.valid := readValidReg
  io.readData.bits.resp   := UInt(0)    // always OK
  
  // register bank read
  val readRegSelect = io.readAddr.bits.addr(addrBits-1, wordSelBits)
  val outputReg = Reg(init=UInt(0, addrBits), next=regBank(readRegSelect))
  io.readData.bits.data   := outputReg
}

