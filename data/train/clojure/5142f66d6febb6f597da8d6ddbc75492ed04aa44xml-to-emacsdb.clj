;; Clojure script to generate csound-opcodes.el
;; Some manual changes may be needed,
;; Zerodbfs needs to be changed to 0dbfs
;; `tab` and `tb` opcodes need to be split up
(ns xml-to-emacsdb
  (:require [clojure.java.io :as io]
            [clojure.xml :as xml]
            [clojure.string :as string]))

(def ELPA-requirements-prefix
  (let [mode (slurp "../csound-mode.el")
        mode (string/replace-first mode "csound-mode" "csound-opcodes")
        find-commentary-tag (.indexOf mode "Commentary:")]
    (str (subs mode 0 (+ 12 find-commentary-tag))
         ";; Auto generated database of opcodes extraced from the manual\n"
         ";;; Code:\n")))

(def ELPA-requirements-postfix
  ";;; csound-opcodes.el ends here")

(def OPCODE-XML-DIR "/home/hlolli/csound/manual/opcodes/")

(def quoted-ampersands
  (loop [docs (rest (file-seq (io/file OPCODE-XML-DIR)))
         xml-string ""]
    (if (empty? docs)
      xml-string
      (recur (rest docs)
             (str xml-string
                  (-> (string/replace
                       (slurp (first docs))
                       "&" "")
                      (string/replace "<command>" "")
                      (string/replace "</command>" "")))))))

(defn parse [s]
  (xml/parse
   (java.io.ByteArrayInputStream. (.getBytes s))))

(def parsed-docs (parse (str "<manual>" quoted-ampersands "</manual>")))

(defn find-synopsis [vek]
  (loop [v vek]
    (if (empty? v)
      "ERROR"
      (if (= (:tag (second (:content (first v)))) :synopsis)
        (apply str (seq (interpose "\n"
                                   (filter #(not (nil? %))
                                           (apply vector
                                                  (for [x (:content (first v))]
                                                    (when (= :synopsis (:tag x))
                                                      (-> (first (:content x))
                                                          (string/replace "\n" "")
                                                          (string/replace "\t" "")
                                                          (string/replace "\\" "")
                                                          (string/replace (re-pattern "\\s+") " ")
                                                          (string/trim)))))))))
        (recur (rest v))))))

(defn find-docstring [vek]
  (loop [v vek]
    (if (empty? v)
      ""
      (if (= (:tag (second (:content (first v)))) :refpurpose)
        (str (nth (:content (first v)) 3))
        (recur (rest v))))))

(defn fix-csound-names [id-str]
  (case id-str
    "Zerodbfs" "0dbfs"
    "notequal" "!="
    "equals" "=="
    id-str))

(def missing-opcodes
  (apply
   str
   (map
    #(format
      "(puthash \"%s\" '(:template \"%s\" :doc \"%s\") csdoc-opcode-database)\n"     
      (nth % 0)
      (nth % 1)
      (nth % 2))
    [["schedkwhen" "schedkwhen ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur [, ip4] [, ip5] [...]" "Adds a new score event generated by a k-rate trigger."]
     ["schedwhen" "schedwhen ktrigger, kinsnum, kwhen, kdur [, ip4] [, ip5] [...]"
      "Adds a new score event."]
     ["massign" "massign midichn, instr" "assigns midi channel to instrument"]
     ["event" "event \"scorechar\", kinsnum, kdelay, kdur, [, kp4] [, kp5] [, ...]" "Generates a score event from an instrument."]
     ["event_i" "event_i \"scorechar\", iinsnum, idelay, idur, [, ip4] [, ip5] [, ...]" "Generates a score event from an instrument."]
     ["prints" "prints \"string\" [, kval1] [, kval2] [...]" "Prints at init-time using a printf() style syntax."]
     ["printks" "printks \"string\", itime [, kval1] [, kval2] [...]" "Prints at k-rate using a printf() style syntax."]
     ["printks2" "printks2 \"string\", kval" "Prints a new value every time a control variable changes using a printf() style syntax."]])))

(defn spit-emacs-file []
  (spit "csound-opcodes.el"
        (loop [docs (:content parsed-docs)
               out ""]
          (if (empty? docs)
            (str
             ELPA-requirements-prefix "\n"
             "(setq csdoc-opcode-database (make-hash-table :test 'equal))\n"
             out missing-opcodes
             "\n (provide 'csound-opcodes)\n" 
             ELPA-requirements-postfix)
            (let [doc (first docs)
                  id (-> doc :attrs :id)
                  id (fix-csound-names id)
                  template (find-synopsis (-> doc :content))
                  docstring (if-not (< 2 (count (-> doc :content)))
                              ""
                              (let [untrimmed (-> doc
                                                  :content (nth 3)
                                                  :content second
                                                  :content first)]
                                (if (string? untrimmed)
                                  (string/trim untrimmed)
                                  (if (map? untrimmed)
                                    (-> untrimmed
                                        :content
                                        first
                                        string/trim)
                                    (str "WTF: " untrimmed)))))]
              (recur (rest docs)
                     (let [strcand (format "(puthash \"%s\" '(:template \"%s\" :doc \"%s\") csdoc-opcode-database)"
                                           id (str template)
                                           (string/replace docstring "\"" "'"))]
                       (if (or (re-find #"null" strcand)
                               (re-find #"ERROR" strcand)
                               (re-find #";" strcand))
                         out (str out strcand "\n")))))))))

;; (spit-emacs-file)


;; (:content ((:content (first (:content parsed-docs))) 3))
;; ((:content ((:content ((:content parsed-docs) 0)) 5)) 1)


;; DANGEROUS version bump function
;; find ./ -type f -exec sed -i -e 's/;; Version: 0\.1\.1/;; Version: 0.1.2/g' {} \;
